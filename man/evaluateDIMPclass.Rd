% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluateDIMPclass.R
\name{evaluateDIMPclass}
\alias{evaluateDIMPclass}
\title{Evaluate DIMPs Classification}
\usage{
evaluateDIMPclass(LR, control.names, treatment.names, column = c(hdiv =
  FALSE, TV = FALSE, wprob = FALSE, pos = FALSE),
  classifier = c("logistic", "pca.logistic", "lda", "qda", "pca.lda",
  "pca.qda"), pval.col = NULL, n.pc = 1, center = FALSE,
  scale = FALSE, interaction = NULL, output = "conf.mat",
  prop = 0.6, num.boot = 100, num.cores = 1L, tasks = 0L,
  seed = 1234, verbose = TRUE)
}
\arguments{
\item{LR}{A list of GRanges objects (LR) including control and treatment
GRanges containing divergence values for each DIMP in the meta-column.
LR is generated by the function 'selectDIMP' Each GRanges object must
correspond to a sample. For example, if  a sample is named 's1', then
this sample can be accessed in the list of GRanges objects as LR$s1.}

\item{control.names}{Names/IDs of the control samples, which must be include
in thr variable LR.}

\item{treatment.names}{Names/IDs of the treatment samples, which must be
included in the variable LR.}

\item{column}{a logical vector for column names for the predictor variables
to be used: Hellinger divergence "hdiv", total variation "TV",
probability of potential DIMP "wprob", and the relative cytosine site
position "pos" in respect to the chromosome where it is located. The
relative position is estimated as (x - x.min)/(x.max - x), where x.min
and x.max are the maximum and minimum for the corresponding chromosome,
repectively. If "wprob = TRUE", then Logarithm base-10 of "wprob" will
be used as predictor in place of "wprob".}

\item{classifier}{Classification model to use. Option "logistic" applies a
logistic regression model; option "lda" applies a Linear Discriminant
Analysis (LDA); "qda" applies a Quadratic Discriminant Analysis (QDA),
"pca.logistic" applies logistic regression model using the Principal
Component (PCs) estimated with Principal Component Analysis (PCA) as
predictor variables. pca.lda" applies LDA using PCs as predictor
variables, and the option "pca.qda" applies a Quadratic Discriminant
Analysis (QDA) using PCs as predictor variables.}

\item{pval.col}{Column number for p-value used in the performance
analysis and estimation of the cutpoints. Default: NULL. If NULL it is
assumed that the column is named "wprob".}

\item{n.pc}{Number of principal components (PCs) to use if the classifier is
not 'logistic'. In the current case, the maximun number of PCs is 4.}

\item{center}{A logical value indicating whether the variables should be
shifted to be zero centered (same as in 'prcomp' {prcomp}). Only used if
classifier = "pcaLDA".}

\item{scale}{A logical value indicating whether the variables should be
scaled to have unit variance before the analysis takes place (same as in
'prcomp' {prcomp}). Only used if classifier = "pcaLDA".}

\item{interaction}{Variable interactions to consider in a logistic
regression model. Any pairwise combination of the variable "hdiv", "TV",
"wprob", and "pos" can be provided. For example: "hdiv:TV", "wprob:pos",
"wprob:TV", etc.}

\item{output}{Type of output to request: output = c("conf.mat", "mc.val",
"boot.all", "all"). See below.}

\item{prop}{Proportion to split the dataset used in the logistic regression:
group versus divergence (at DIMPs) into two subsets, training and
testing.}

\item{num.boot}{Number of bootstrap validations to perform in the evaluation
of the logistic regression: group versus divergence (at DIMPs).}

\item{num.cores, tasks}{Paramaters for parallele computation using package
\code{\link[BiocParallel]{BiocParallel-package}}: the number of cores to
use, i.e. at most how many child processes will be run simultaneously
(see \code{\link[BiocParallel]{bplapply}} and the number of tasks per job
(only for Linux OS).}

\item{seed}{Random seed used for random number generation.}

\item{verbose}{if TRUE, prints the function log to stdout}
}
\value{
output = "conf.mat" will perform a logistic regression group versus
    divergence (at DIMPs) to evaluate the discrimination between
    control-DIMPs and treatment-DIMPs. The evaluation of this classification
    is provided through the function 'confusionMatrix' from R package
    'caret'. "mc.val" will perform a 'num.boot'-times Monte Carlo
    (bootstrap) validation and return a summary. By default function
    'confusionMatrix' from R package caret' randomly splits the sample into
    two subsets, training and testing, according to the supplied proportion
    'prop' (i.e., prop = 0.6). After selecting output = "mc.val", the
    function 'confusionMatrix' will be executed 'num.boot'-times, each time
    performing a different random split of the sample. "boot.all" same as
    "mc.val" plus a matrix with statistcs reported by 'confusionMatrix'.
    "all" return a list with all the mentioned outputs.
}
\description{
For a given cutpoint (previously estimated with the function
    estimateCutPoint), 'evaluateDIMPclass' will return the evaluation of the
    classification of DIMPs into two clases: DIMPS from control and DIMPs
    from treatment samples.
}
\details{
The regulatory methylation signal is also an output from a natural
    process that continuously takes place across the ontogenetic development
    of the organisms. So, we expect to see methylation signal on natural
    ordinary conditions. Here, to distinguish a control methylation signal
    from a treatment, three classification models are provided: 1) logistic,
    2) Linear Discriminant Analysis (LDA) and 3) Quadratic Discriminant
    Analysis (QDA). In particular, four predictor variables can be used:
    Hellinger divergence "hdiv", total variation "TV", probability of
    potential DIMP "wprob" and DIMP genomic coordinated "pos". Principal
    component analysis (PCA) is used to convert a set of observations of
    possibly correlated predictor variables into a set of values of linearly
    uncorrelated variables (principal components, PCs). The PCs are used as
    new, uncorrelated predictor variables for LDA, QDA, and logistic
    classifiers.

    A classification result with low accuracy and compromising values from
    other classification performance indicators (see below) suggest that the
    treatment does not induce a significant regulatory signal different
    from control.
}
\examples{
set.seed(123) ## To set a seed for random number generation
## GRanges object of the reference with methylation levels in
## its matacolumn
num.points <- 5000
Ref <- makeGRangesFromDataFrame(
    data.frame(chr = '1',
            start = 1:num.points,
            end = 1:num.points,
            strand = '*',
            p1 = rbeta(num.points, shape1 = 1, shape2 = 1.5)),
    keep.extra.columns = TRUE)

## List of Granges objects of individuals methylation levels
Indiv <- GRangesList(
    sample11 = makeGRangesFromDataFrame(
        data.frame(chr = '1',
            start = 1:num.points,
            end = 1:num.points,
            strand = '*',
            p2 = rbeta(num.points, shape1 = 1.5, shape2 = 2)),
         keep.extra.columns = TRUE),
    sample12 = makeGRangesFromDataFrame(
        data.frame(chr = '1',
            start = 1:num.points,
            end = 1:num.points,
            strand = '*',
            p2 = rbeta(num.points, shape1 = 1.6, shape2 = 2)),
        keep.extra.columns = TRUE),
    sample21 = makeGRangesFromDataFrame(
        data.frame(chr = '1',
            start = 1:num.points,
            end = 1:num.points,
            strand = '*',
            p2 = rbeta(num.points, shape1 = 40, shape2 = 4)),
        keep.extra.columns = TRUE),
    sample22 = makeGRangesFromDataFrame(
        data.frame(chr = '1',
            start = 1:num.points,
            end = 1:num.points,
            strand = '*',
            p2 = rbeta(num.points, shape1 = 41, shape2 = 4)),
        keep.extra.columns = TRUE))
## To estimate Hellinger divergence using only the methylation levels.
HD <- estimateDivergence(ref = Ref, indiv = Indiv, meth.level = TRUE,
                            columns = 1)
## To perform the nonlinear regression analysis
nlms <- nonlinearFitDist(HD, column = 4, verbose = FALSE)

## Next, the potential signal can be estimated
PS <- getPotentialDIMP(LR = HD, nlms = nlms, div.col = 4, alpha = 0.05)

## The cutpoint estimation used to discriminate the signal from the noise
cutpoints <- estimateCutPoint(PS, control.names = c("sample11", "sample12"),
                            treatment.names = c("sample21", "sample22"),
                            div.col = 4, verbose = TRUE)
## DIMPs are selected using the cupoints
DIMPs <- selectDIMP(PS, div.col = 4, cutpoint = min(cutpoints$cutpoint))

## Classification of DIMPs into two clases: DIMPS from control and DIMPs from
## treatment samples and evaluation of the classifier performance (for more
## details see ?evaluateDIMPclass).
conf.mat <- evaluateDIMPclass(DIMPs,
                            column = c(hdiv = TRUE, TV = TRUE,
                            wprob = TRUE, pos = FALSE),
                            control.names = c("sample11", "sample12"),
                            treatment.names = c("sample21", "sample22"))
confusion.matrix <- conf.mat$conf.mat
model.fit <- summary(conf.mat$model)
}
